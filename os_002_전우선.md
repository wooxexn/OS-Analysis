# V6 Lions Code `main()` 코드 분석 
성결대학교 컴퓨터공학과 20170861 전우선 

## 서론  
이 과제에서는 V6 Lions Code의 `main()` 함수와 관련된 코드를 분석하고, 시스템 초기화 과정에서 코드가 수행하는 중요한 역할을 이해하려는 목적을 가지고 있다. 이 분석은 주어진 코드가 어떻게 메모리 초기화, 프로세스 관리, 세그먼트 설정 등의 시스템 초기화 작업을 수행하는지를 명확히 하고자 한다. 특히, 시스템에서 메모리 할당과 프로세스 생성 과정에서 중요한 동작들이 어떻게 이루어지는지를 중점적으로 살펴볼 수 있다.

## 분석 목표  
- 시스템 초기화와 메모리 관리 작업을 분석하여, 코드가 메모리 세그먼트 초기화 및 해제를 어떻게 처리하는지 이해한다.  
- 프로세스 생성 및 관리, 특히 프로세스 플래그 설정과 관련된 코드 흐름을 분석한다.  
- 하드웨어 장치 및 시계 설정, 그리고 메모리 블록 해제 과정을 면밀히 조사한다.  
- 시스템 안정성 및 최적화를 위한 개선 여지가 있는지 파악한다.

## 코드분석

### 코드

```c
1551: { // main 함수 시작, 시스템 초기화 과정의 시작
1552:     extern schar; // schar라는 외부 변수를 선언함. 이는 다른 파일에서 선언된 변수로, 여기서는 사용되기 전에 외부에서 정의되어야 함.
1553:     register i, *p; // register로 변수 i와 포인터 p를 선언함. i는 루프나 인덱스 역할을, p는 포인터로 사용할 수 있음
1554:     updlock = 0; // 'updlock' 변수를 0으로 초기화하여 시스템 잠금 상태를 해제하는 역할을 함
1555:     i = *ka6 + USIZE; // i 변수에 'ka6'로 지정된 주소값과 'USIZE'를 더하여 메모리 주소를 설정
1556:     UISD->r[0] = 077406; // UISD 레지스터의 첫 번째 값을 077406으로 설정. UISD는 하드웨어 레지스터를 나타냄.

1557:     for(;;) { // 무한 루프 시작. 시스템 초기화 시 필요한 작업을 계속 반복
1558:         UISA->r[0] = i; // UISA 레지스터의 첫 번째 값을 i로 설정하여 메모리 주소를 레지스터에 할당함
1559:         if(fuibyte(0) < 0) // fuibyte 함수가 음수 값을 반환하면 루프를 종료하며 메모리 오류를 나타낼 수 있음
1560:             break; // fuibyte 함수가 음수 값을 반환하면 루프 종료
1561:         clearseg(i); // clearseg 함수로 메모리 세그먼트 i를 초기화함
1562:         maxmem++; // 최대 메모리 크기를 증가시킴. 메모리 확장을 나타낼 수 있음
1563:         mfree(coremap, 1, i); // 메모리 블록을 해제함. coremap에서 1개의 블록을 해제
1564:         i++; // i를 증가시켜 다음 메모리 주소로 이동
1565:     } // 무한 루프 종료

1566:     if(cputype == 70) { // CPU 타입이 70일 경우, 특수 설정을 수행
1567:         for(i = 0; i < 62; i += 2) { // i를 2씩 증가시키며 62까지 반복
1568:             UBMAP->r[i] = i << 12; // 메모리 맵을 설정합니다. i를 12비트 왼쪽으로 시프트하여 UBMAP의 값으로 설정
1569:             UBMAP->r[i+1] = 0; // 추가적인 메모리 맵 설정
1570:         }
1571:         printf("mem = %l\n", maxmem * 5 / 16); // 최대 메모리 크기를 계산하여 5/16 비율로 출력
1572:         maxmem = min(maxmem, MAXMEM); // maxmem과 MAXMEM 중 작은 값을 선택하여 최대 메모리 크기를 설정
1573:         mfree(swapmap, nswap, swplo); // 스왑맵을 해제합니다. 스왑 공간에 할당된 메모리 블록을 해제
1574:         proc[0].p_addr = *ka6; // 첫 번째 프로세스의 주소를 ka6로 설정
1575:         proc[0].p_size = USIZE; // 첫 번째 프로세스의 크기를 USIZE로 설정
1576:         proc[0].p_stat = SRUN; // 첫 번째 프로세스 상태를 실행 중(SRUN)으로 설정
1577:         proc[0].p_flag |= SLOAD | SSYS; // 프로세스 플래그를 SLOAD와 SSYS로 설정하여 시스템 프로세스로 지정
1578:         u.u_procp = &proc[0]; // 현재 프로세스를 첫 번째 프로세스로 설정

1579:         UISA->r[7] = ka6[1]; // UISA 레지스터의 7번째 값을 ka6[1]로 설정하여 IO 세그먼트로 설정
1580:         UISD->r[7] = 077406; // UISD 레지스터의 7번째 값을 077406으로 설정
1581:         lks = CLOCK1; // lks 레지스터에 CLOCK1 값을 설정하여 시계 초기화
1582:         if(fuiword(lks) == -1) { // CLOCK1을 읽을 수 없다면,
1583:             lks = CLOCK2; // CLOCK2로 설정
1584:             if(fuiword(lks) == -1) // CLOCK2도 읽을 수 없다면,
1585:                 panic("no clock"); // 시스템 종료 함수 호출
1586:         }
1587:         *lks = 0115; // lks 레지스터에 특정 값 0115를 설정하여 시계 값을 초기화
1588:         cinit(); // 시스템 초기화, 캐릭터 장치 초기화 함수 호출
1589:         binit(); // 블록 장치 초기화 함수 호출
1590:         iinit(); // I-node 초기화 함수 호출
1591:         rootdir = iget(rootdev, ROOTINO); // 루트 디렉토리 i-node 가져오기
1592:         rootdir->i_flag &= ~ILOCK; // 루트 디렉토리 잠금 해제
1593:         u.u_cdir = iget(rootdev, ROOTINO); // 현재 디렉토리 설정
1594:         u.u_cdir->i_flag &= ~ILOCK; // 현재 디렉토리 잠금 해제
1595:         if(newproc()) { // 새로운 프로세스를 생성하는 함수 호출
1596:             expand(USIZE + 1); // 프로세스 크기 확장
1597:             estabur(0, 1, 0, 0); // 세그먼트 설정 함수 호출
1598:             copyout(icode, 0, sizeof icode); // 초기 코드 복사
1599:             return; // 프로세스 초기화 후 종료
1600:         }
1601:         sched(); // 프로세스 스케줄러 실행
1602:     }

1603: estabur(nt, nd, ns, sep) { // 프로세스 세그먼트 설정 함수
1604:         register a, *ap, *dp;

1605:         if(sep) { // 세그먼트를 분리할 경우
1606:                 if(cputype == 40) // CPU 타입에 따른 처리
1607:                         goto err; // 오류 처리
1608:                 if(nseg(nt) > 8 || nseg(nd) + nseg(ns) > 8) // 세그먼트 수가 8개를 초과하면 오류 처리
1609:                         goto err;
1610:         } else
1611:                 if(nseg(nt) + nseg(nd) + nseg(ns) > 8) // 세그먼트 총합이 8개를 초과하면 오류 처리
1612:                         goto err;

1613:         if(nt + nd + ns + USIZE > maxmem) // 메모리 총합이 최대 메모리 크기를 초과하면 오류 처리
1614:                 goto err;

1615:         a = 0; // 주소 변수 a를 0으로 초기화
1616:         ap = &u.u_uisa[0]; // 사용자 세그먼트 주소 설정
1617:         dp = &u.u_uisd[0]; // 사용자 데이터 주소 설정

1618:         while(nt >= 128) { // 텍스트 영역을 128 단위로 분할하여 설정
1619:                 *dp++ = (127 << 8) | RO; // 읽기 전용 설정
1620:                 *ap++ = a; // 주소 설정
1621:                 a += 128; // 주소 증가
1622:                 nt -= 128; // 텍스트 크기 감소
1623:         }

1624:         if(nt) { // 남은 텍스트 크기 처리
1625:                 *dp++ = ((nt-1) << 8) | RO; // 읽기 전용 설정
1626:                 *ap++ = a; // 주소 설정
1627:         }

1628:         if(sep) // 세그먼트를 분리하는 경우
1629:         while(ap < &u.u_uisa[8]) {
1630:                 *ap++ = 0; // 주소 초기화
1631:                 *dp++ = 0; // 데이터 초기화
1632:         }

1633:         a = USIZE; // 데이터 영역 크기 설정
1634:         while(nd >= 128) { // 데이터 영역을 128 단위로 분할
1635:                 *dp++ = (127 << 8) | RW; // 읽기/쓰기 설정
1636:                 *ap++ = a; // 주소 설정
1637:                 a += 128; // 주소 증가
1638:                 nd -= 128; // 데이터 크기 감소
1639:         }

1640:         if(nd) { // 남은 데이터 크기 처리
1641:                 *dp++ = ((nd-1) << 8) | RW; // 읽기/쓰기 설정
1642:                 *ap++ = a; // 주소 설정
1643:                 a += nd; // 주소 증가
1644:         }

1645:         while(ap < &u.u_uisa[8]) { // 남은 주소를 초기화
1646:                 *dp++ = 0;
1647:                 *ap++ = 0;
1648:         }

1649:         if(sep) // 세그먼트를 분리하는 경우
1650:         while(ap < &u.u_uisa[16]) {
1651:                 *dp++ = 0;
1652:                 *ap++ = 0;
1653:         }

1654:         a += ns; // 스택 크기 증가
1655:         while(ns >= 128) { // 스택 영역을 128 단위로 분할
1656:                 a -= 128; // 주소 감소
1657:                 ns -= 128; // 스택 크기 감소
1658:                 *--dp = (127 << 8) | RW; // 읽기/쓰기 설정
1659:                 *--ap = a; // 주소 설정
1660:         }

1661:         if(ns) { // 남은 스택 크기 처리
1662:                 *--dp = ((128 - ns) << 8) | RW | ED; // 읽기/쓰기, 확장 영역 설정
1663:                 *--ap = a - 128; // 주소 설정
1664:         }

1665:         if(!sep) { // 세그먼트를 통합하는 경우
1666:                 ap = &u.u_uisa[0];
1667:                 dp = &u.u_uisa[8];
1668:                 while(ap < &u.u_uisa[8]) // 주소 통합
1669:                         *dp++ = *ap++;
1670:                 ap = &u.u_uisd[0];
1671:                 dp = &u.u_uisd[8];
1672:                 while(ap < &u.u_uisd[8]) // 데이터 통합
1673:                         *dp++ = *ap++;
1674:         }

1675:         sureg(); // 하드웨어 세그먼트 업데이트
1676:         return(0); // 성공적으로 완료

1677: err: // 오류 처리
1678:         u.u_error = ENOMEM; // 메모리 부족 오류 설정
1679:         return(-1); // 오류 발생 시 -1 반환
1680: }
```

## 상세 분석

### 1. 메모리 초기화 및 관리  
`main()` 함수에서 메모리 초기화 및 관리는 시스템 초기화의 중요한 부분을 차지한다. `clearseg(i)`와 `mfree()` 함수가 반복적으로 호출되며 메모리 세그먼트를 해제하고 초기화하는 역할을 한다. `i`는 메모리 주소를 추적하고, `fuibyte(0)` 함수는 해당 주소에서 메모리 오류를 감지한다. 메모리 블록이 초기화되며, 시스템에서 사용할 수 있는 메모리 영역이 확장된다.

`i++`로 메모리 주소를 순차적으로 증가시키며, 이는 연속적으로 메모리 영역을 처리하는 데 사용된다. 만약 메모리 오류가 발생하면 `fuibyte(0)` 함수가 음수 값을 반환하며, 루프가 종료된다. 이 과정에서 메모리의 유효성을 점검하고 오류를 처리하는 중요한 역할을 한다. `maxmem`은 시스템이 사용할 수 있는 메모리 크기를 추적하며, 이를 통해 시스템 메모리의 용량을 관리한다.

특히 `cputype == 70`일 경우, CPU에 특화된 설정을 통해 메모리 맵을 설정한다. 이는 특정 CPU 환경에 맞는 메모리 주소와 할당 방식을 설정하기 위한 작업으로, `UBMAP` 레지스터에 값을 설정하여 시스템의 메모리 영역을 할당하고, 메모리 주소를 적절하게 조정한다.

이 과정은 운영체제에서 메모리 충돌을 방지하고, 효율적인 메모리 관리를 통해 시스템 성능을 최적화하는 중요한 역할을 한다.

### 2. 시스템 프로세스 설정  
시스템 프로세스를 설정하는 부분에서는 `proc[0]`을 첫 번째 프로세스로 지정하고, 해당 프로세스의 주소, 크기, 상태 및 플래그를 설정한다. `SLOAD`와 `SSYS` 플래그를 설정하여 프로세스가 시스템 프로세스로 지정된다. `SLOAD` 플래그는 프로세스가 시스템 메모리에 로드된 상태임을 나타내며, `SSYS` 플래그는 해당 프로세스가 시스템 프로세스로 실행되고 있다는 의미이다.

**`newproc()`** 함수가 호출되어 새로운 프로세스를 생성하고, 프로세스의 메모리 할당과 세그먼트 설정을 담당한다. 새로운 프로세스가 생성되면, **`expand(USIZE + 1)`** 함수로 프로세스 크기가 확장되고, **`estabur(0, 1, 0, 0)`** 함수로 프로세스의 세그먼트가 설정된다. 이 과정은 프로세스의 메모리 구조를 정의하고 관리하는 중요한 작업이다.

운영체제에서 프로세스를 생성하고 관리하는 것은 가장 중요한 작업 중 하나로, 시스템이 여러 프로세스를 효율적으로 관리하고 실행할 수 있게 한다. 각 프로세스는 독립적으로 실행되며, 필요한 자원을 할당받아 운영된다.

### 3. 시계 및 하드웨어 설정  
시계와 하드웨어 설정은 시스템 초기화 과정에서 중요한 역할을 한다. `CLOCK1`과 `CLOCK2` 레지스터는 시스템에서 시간을 측정하고 관리하는 장치들이다. 이들 레지스터들을 설정하고, 해당 값을 읽어 시계가 정상적으로 작동하는지 확인한다. 만약 시계를 읽을 수 없으면 시스템 패닉을 발생시키며, 이는 시스템의 안정성을 보장하는 중요한 절차다.

`lks` 레지스터에 시계 값을 설정하고, `cinit()`, `binit()`, `iinit()` 함수를 호출하여 캐릭터 장치, 블록 장치, 파일 시스템을 초기화한다. 이를 통해 시스템이 제대로 작동할 수 있는 상태로 설정되며, 사용자의 요청을 처리하고 데이터를 입출력하는 데 필수적인 작업이 수행된다.

시계와 하드웨어 장치의 초기화가 정확히 이루어져야 시스템이 정확한 시간 추적을 하고, 하드웨어 자원을 올바르게 할당할 수 있다. 이 과정을 통해 시스템의 신뢰성을 높이는 것이 매우 중요하다.

### 4. 세그먼트 설정  
**`estabur()`** 함수는 프로세스의 세그먼트를 설정하는 핵심적인 역할을 한다. 프로세스는 텍스트 영역, 데이터 영역, 스택 영역으로 나누어지며, 각 세그먼트는 메모리 주소를 128 단위로 할당받고, 이를 통해 효율적으로 관리된다. 세그먼트의 크기는 CPU 타입에 따라 달라지며, `nseg()` 함수를 통해 세그먼트 수를 확인하고 관리한다.

세그먼트가 할당될 수 있는 최대 범위는 `nseg()` 함수를 통해 보장되며, 세그먼트 수가 너무 많거나 메모리 할당이 너무 크면 오류가 발생한다. 이 과정은 시스템의 안정성 및 성능을 보장하는 중요한 요소로, 메모리 보호와 접근 제어를 수행하는 역할을 한다.

프로세스가 독립적인 메모리 공간을 가지며, 다른 프로세스와 충돌하지 않도록 보호하기 위해 세그먼트 설정은 중요한 작업이다.

### 5. 시스템 안정성 및 최적화  
`sureg()` 함수는 하드웨어 세그먼트를 업데이트하는 역할을 한다. 이 함수는 프로세스의 메모리 상태를 하드웨어에 맞게 조정하고, 메모리 상의 오류를 최소화한다. 시스템의 안정성을 유지하기 위해 세그먼트를 하드웨어에 맞게 업데이트하는 작업이다.

시스템의 안정성을 높이는 최적화 작업은 메모리 관리, 프로세스 스케줄링, I/O 처리 등 여러 부분에서 이루어진다. 모든 자원들이 효율적으로 관리되어 시스템에서 예기치 않은 오류를 방지하고, 성능을 극대화할 수 있도록 돕는다.

## 주요 사항
- **메모리 초기화와 관리**: `clearseg()`와 `mfree()` 함수는 메모리 블록을 반복적으로 해제하고 세그먼트를 초기화한다. 이 작업을 통해 시스템은 사용할 수 있는 메모리 영역을 효율적으로 관리한다.  
- **프로세스 생성**: `newproc()` 함수가 호출되어 새로운 프로세스를 생성하고, 메모리 크기를 확장하는 기능을 수행한다.  
- **시스템 장치 초기화**: 시계와 I/O 세그먼트 초기화는 `CLOCK1`과 `CLOCK2` 레지스터를 통해 이루어진다. 이 작업은 시스템의 안정성을 보장하고, 하드웨어 자원을 효율적으로 관리한다.  
- **향후 개선**: 메모리 할당과 해제의 효율성을 높이고, 메모리 중복 처리 및 오류 발생 시 예외 처리 부분에서 더욱 세밀한 처리가 필요하다. 이를 통해 시스템의 안정성과 성능 향상을 이룰 수 있다.  

## 결론  
V6 Lions Code의 `main()` 함수는 시스템 초기화 과정에서 중요한 역할을 하며, 여러 장치 초기화와 메모리 관리 작업을 수행한다. 이 코드는 시스템이 정상적으로 동작할 수 있도록 준비하며, 각 기능들이 어떻게 상호작용하는지를 분석할 수 있었다.